#!/usr/bin/env Rscript

################  LOAD OPTPARASE
library("optparse")

################ DEFINE THE INPUT PARAMETERS
option_list = list(
  make_option(c("-s", "--summary"), type="character", default=NULL,help="Path to the folder that contain the base calls summaries generated by smMIP_level_raw_and_consensus_pileups.R [Mendatory]", metavar="character"),
  make_option(c("-f", "--file"), type="character", default=NULL,help="Path to the input file that descibes the configuration of the assay [Mendatory]", metavar="character"),
  make_option(c("-a", "--alleles"), type="character", default=NULL,help="Annotated panel file [Mendatory]", metavar="character"),
  make_option(c("-c", "--code"), type="character", default=getwd(),help="Path to smMIP tools source functions file. If not supplied, it is assumed that the file (smMIPs_Function.R) is located in the same folder as this code (calling_mutations.R)", metavar="character"),
  make_option(c("-b", "--binomial"), type="character", default="sum",help="Options are 'sum' or 'max'. Indicates whether allele-specific error rates will be defined by the sum of alternative bases divided by the sum of reference bases across all the samples used for error modeling, or by the observed maximum", metavar="character"),
  make_option(c("-g", "--overlap.coverage"), type="integer",default=10,help="Determine the minimum coverage at read1 and read2 to consider during P-value calculations", metavar="character"),
  make_option(c("-m", "--maf"), type="numeric",default=0.001,help="Minor allele frequency cut-off. Being used to remove known SNPs from being included in the error models", metavar="character"),
  make_option(c("-v", "--vaf"), type="numeric",default=0.05,help="Variant allele frequency cut-off. Being used to remove personal SNPs and reduce the presence of high VAF, authentic SNVs in the error models", metavar="character"),
  make_option(c("-p", "--pval"), type="numeric",default=0.05,help="P-value cut-off to call mutations. If set to '1' all the alleles with p-value<=0.05 prior to Bonferroni correction will be reported)" , metavar="character"),
  make_option(c("-d", "--drop"), type="numeric",default=2,help="Being used to mark mutations that do not have at least d-fold higher VAF as compared with VAF of other samples in the cohort with non-reference alleles for the same mutation. Notes: 1) If multiple samples will be reported with the same mutation, VAF differences will be calculated based on the sample with the lowest VAF. 2) A single sample with <d fold lower VAF is allowed" , metavar="character"),
  make_option(c("-t", "--threads"), type="integer", default=1,help="The number of cores to use for parallel processing", metavar="character"),
  make_option(c("-o", "--output"), type="character", default=NULL,help="Path for the output file. If not supplied, the output will be saved within the folder that contain the input configuration file", metavar="character"))

#takes user input parameters
opt_parser = OptionParser(option_list=option_list)
opt = parse_args(opt_parser);
if ( is.null(opt$file) | is.null(opt$alleles) ){
  print_help(opt_parser)
  stop("-s, -f and -a parameters must be supplied", call.=FALSE)
}

if (is.null(opt$output)){
  opt$output=dirname(opt$file)
}

if (is.null(opt$code)){
  source(paste0(getwd(),"/smMIPs_Functions.R"))
} else {
  source(paste0(opt$code,"/smMIPs_Functions.R"))
}

opt$overlap.coverage2=2*opt$overlap.coverage

################ LOAD LIBRARIES
library("data.table")
library("parallel")

#Print all the parameters
cat("###############################\n")
cat("        Run Parameters\n")
cat("###############################\n")
print(opt)
cat("###############################\n")
cat("            Running...\n")
cat("###############################\n")


################ CREATE A DATA OBJECT
data=list()

################  LOAD THE ANNOTATED PANEL FILE
data=load.annotation.file(data)

################  POPULATE THE DATA OBJECT WITH RAW READS PILEUP INFORMATION
data=populate(data)

################  LEVRAGING PRIOR KNOWLEDGE FOR PROPER USE OF THE CONTROLS
#print("Leveraging COSMIC data and information concerning known polymorphisms to increase sensitivity in those genomic positions",quote =F)
data=prior.knowledge(data)

################  CALCULATE P-VALUES
data=pval.calculation(data)
tab=as.data.frame(which(is.na(data$pval.minus) & is.na(data$pval.plus),arr.ind = T))
l=nrow(tab)
if(length(l)>0 & l!=0 ){
  print(paste0("Working on the last ", l," alleles"))
  data=pval.calculation.remained(data)
}

########## P-VALUE CORRECTIONS
#Correcting by DNA strand (Read1 and Read2 of the paired reads)
#The maximum P-value is determine (aiming towards reducing false positives).
#if there isnt enough coverage (user defined parameter) at one of the two strands the information captured in the strand with enough coverage will used to determine the p-value.
#indels do not require validation by both DNA strands
#The output is one "merged" p-value
data=pval.correction.cdna.strand(data)

#Correcting by overlapping smMIPs
#The maximum P-value is determine (aiming towards reducing false positives) among smMIPs with enough coverage (user defined parameter)
#alleles that were investigated with multiple smMIPs will have the same "merged" p-value (different p-value for each allele, same p-value across smMIPs)
#the same "merged" p-value will be also assigned to those alleles investigated by the low performed smMIPS
#indels do not require validation by multiple smMIPs
data=pval.correction.overlapping.smmips(data)

#Correcting by technical replicates
#The maximum P-value is determine (aiming towards reducing false positives).
#if there isnt enough coverage (user defined parameter) at one of the two replicates, the information captured in the replicate with enough coverage will be used to determine the p-value.
if(length(which(!is.na(data$samples$replicate)))>0){ #experiment with replicates
  data=pval.correction.technical.replicates(data)
}

################  GENERATE A TABLE FOR MUTATIONS THAT PASSED THE P-VALUE CUT-OFF
ps=dim(data$annotated.panel)[1]
if(opt$pval==1){
  opt$pval=0.05
} else {
  opt$pval=opt$pval/ps
}

data=pval.passed.mutations(data)

########## ADDING SSCS INFORMATION
if(length(list.files(opt$summary,pattern="_sscs_pileup.txt"))>0){
  data=adding.sscs.info(data)
}

##########  RECALCULATE THE VAF USING THE DATA OF BOTH THE DNA STRANDS
data=vaf.calculation.dna.strand(data)
cat("Allele frequencies are now calculated based on both the plus and minus replicated DNA strands\n")

########## ADDING SEQUENCING BATCH INFORMATION (part1)
#for each mutation reports the the number of samples and number of paired samples (replicates) that pass the p-value cut-off.
#if replicates does not exist, it report just the number of samples that passed the P-value cut-off
#The user can use this information to prioritize mutation calls and to estimate how well error rates in the called alleles were modeled.
data=adding.batch.info1(data)

########## CHECKING FOR EACH MUTATIONS IF THE READS SUPPORTING THE ALTERNATIVE ALLELE COULD OF COME FROM OTHER SAMPLES BASED ON THE READS' UMIs SEQUENCES
#The user can consider using this information to remove low VAF mutation calls without any support of unique tag not included in other samples
if(length(which(names(data$calls)=="SSCS.UMIs"))>0){ #if the user choose to include this information in the sscs pilups
  data=read.sample.misplacement(data)
}

##########  RECALCULATE THE VAF USING THE DATA FROM OVERLAPPING SMMIPS
data=vaf.calculation.overlapping.smmips(data)
cat("Allele frequencies are now calculated based on overlapping smMIPs\n")


##########  RECALCULATE THE VAF USING THE DATA OF BOTH THE TECHNICAL REPLICATES
if(length(which(!is.na(data$samples$replicate)))>0){
  data=vaf.calculation.technical.replicates(data)
  cat("Allele frequencies are now calculated based on sample replicates\n")
}

########## ADDING SEQUENCING BATCH INFORMATION (part2)
#Counting how many samples were detected with higher VAF than the sample with the reported mutation (independently from the p-value)
#The user can use this information to prioritize mutation calls and to estimate how well error rates in the called alleles were modeled.
data=adding.batch.info2(data)

########## ADDING ADDITIONAL FLAGS
data=additional.flags(data)

########## WRITING THE MUTATION TABLE OUTPUT
if(length(which(!is.na(data$samples$replicate)))>0){ #experiment with replicates
  data$calls=data$calls[,c("sample_ID","smMIP","chr","pos","ref","alt","gene","protein","cosmic","maf","variant_type","cadd_scaled",
                           "P-value","P-value.Bonferroni","num.pval.pass","pass.pval.in.pairs","non.ref.counts","total.depth",
                           "allele.frequency","samples.with.higher.vaf","higher.vaf","lower.vaf",
                           "SSCS.non.ref.counts","SSCS.total.depth","SSCS.family.size","SSCS.in.family.non.ref.vaf","SSCS.allele.frequency","SSCS.overlap","flags")]
} else{
  data$calls=data$calls[,c("sample_ID","smMIP","chr","pos","ref","alt","gene","protein","cosmic","maf","variant_type","cadd_scaled",
                           "P-value","P-value.Bonferroni","num.pval.pass","non.ref.counts","total.depth",
                           "allele.frequency","samples.with.higher.vaf","higher.vaf","lower.vaf",
                           "SSCS.non.ref.counts","SSCS.total.depth","SSCS.family.size","SSCS.in.family.non.ref.vaf","SSCS.allele.frequency","SSCS.overlap","flags")]
}

write.table(data$calls,file=paste0(opt$output,"/called_mutations.txt"),col.names = T,row.names = F,quote = F,sep = '\t')
print(paste("A table reporting the identified mutations (called_mutations.txt) was written to",opt$output))

cat("\n")
cat("###############################\n")
cat("             DONE\n")
cat("###############################\n")
