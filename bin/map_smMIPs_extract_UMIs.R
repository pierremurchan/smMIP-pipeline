#!/usr/bin/env Rscript

################  LOAD OPTPARSE
library("optparse")
library("parallel")

################ DEFINE THE INPUT PARAMETERS
option_list = list(
  make_option(c("-b", "--bam.file"), type="character", default=NULL,help="Path to the bam file [MENDATORY]", metavar="character"),
  make_option(c("-p", "--panel.file"), type="character", default=NULL,help="Path to the smMIP design file [MENDATORY]", metavar="character"),
  make_option(c("-s", "--sample.name"), type="character", default=NULL,help="Sample ID that will be used to name the output bam [MENDATORY]", metavar="character"),
  make_option(c("-o", "--output"), type="character", default=NULL,help="Path for output files. A new folder which is named based on the -s parameter will be generated by default. If the path was not supplied, the sample folder will be generated within the folder that contain the bam files", metavar="character"),
  make_option(c("-c", "--code"), type="character", default=getwd(),help="Path to smMIP tools source functions file. If not supplied, it is assumed that the file (smMIPs_Function.R) is located in your working directory", metavar="character"),
  make_option(c("-f", "--filtered.reads"), type="character", default="n",help="Options are 'y' or 'n'. Output a sam file that contain the filtered reads. A sam file for the non-filtered reads will also be generated", metavar="character"),
  make_option(c("-t", "--threads"), type="integer", default=1,help="The number of cores to use for parallel processing", metavar="character"),
  #WE RECOMMEND NOT CHANGING THE 2 PARAMETERS BELOW UNLESS YOU UNDERSTAND THE RELATED FUNCTIONS AND THE CONSEQUENCES OF CHANGING THESE PARAMETERS
  make_option(c("-O", "--OVERLAP"), type="numeric", default=0.95,help="Fine-tuning the overlap between reads and smMIPs. See the map.smip_to_site function for more information", metavar="character"),
  make_option(c("-M", "--MAPQ"), type="numeric", default=50,help="MAPQ cut-off. See the filter.on.mappingscore function for more information", metavar="character"))

#Takes user input parameters
opt_parser = OptionParser(option_list=option_list)
opt = parse_args(opt_parser);
if (is.null(opt$bam.file) | is.null(opt$panel.file) | is.null(opt$sample.name)){
  print_help(opt_parser)
  stop("-b, -p and -s parameters must be supplied", call.=FALSE)
}

if (is.null(opt$code)){
  source(paste0(getwd,"/smMIPs_Functions.R"))
} else {
  source(paste0(opt$code,"/smMIPs_Functions.R"))
}

if (is.null(opt$output)){
  opt$output=dirname(opt$bam.file)
} else if (!dir.exists(opt$output)){
      dir.create(opt$output)
  }
dir.create(paste0(opt$output,"/",opt$sample.name))


################  LOAD LIBRARIES
library("Rsamtools")
library("dplyr")
library("data.table")


#Print all the parameters
cat("###############################\n")
cat("        Run Parameters\n")
cat("###############################\n")
print(opt)
cat("###############################\n")
cat("            Running...\n")
cat("###############################\n")

################ CREATE A DATA OBJECT
data<-list()
cat("Loading bam\n")
data$samtable<-load.bam(opt$bam.file)
data$panel<-load.panel(opt$panel.file)
data$summary<-list()
data$filtered<-data$samtable
data$filtered$reason<-NA
data$filtered<-data$filtered[0,]
data$summary$total.unfiltered.reads=dim(data$samtable)[1]

################ FILTER THE READS AND SAVING THOSE INTO A SEPARATE OBJECT
data<-filter.on.mappingscore(data)
data<-filter.on.flag(data)
data<-filter.on.mate_distance(data)
data<-filter.on.hard.clip(data)
data<-filter.on.mate_missing(data)

################ CREATE READ-SMMIP LINKAGES (MATCH TO EACH READ ITS SMMIP OF ORIGIN)
data<-map.smips(data)

################ FILTER OFF-TARGET ALIGNED READS
data<-filter.offtarget(data)

################ EXTRACT UNIQUE-MOLECULAR-IDENTIFIERS (UMI) SEQUENCE
if((length(unique(data$panel$length.left.umi))==1 & 0 %in% unique(data$panel$length.left.umi)) &
   (length(unique(data$panel$length.right.umi))==1 & 0 %in% unique(data$panel$length.right.umi))){
  cat("No UMIs were detected\n")
} else {
  cat("Extracting UMIs\n")
  data<-extract_umi(data)
}

################ DETERMINE COVERAGE PER SMMIP AND WRITING FILTERED READS SUMMARY FILES
cat("Writing coverage per smMIP and filtered reads summary files\n")
data$summary$usable_reads<-dim(data$samtable)[1]
write.table(data$summary,file=paste0(opt$output,"/",opt$sample.name,"/",opt$sample.name,"_filtered_read_counts.txt"),col.names = T,row.names = F,quote = F,sep = '\t')

tab=data.frame(smmips=data$panel$id,coverage=0)
x=table(data$samtable$smMIP)
tab$coverage[match(names(x),tab$smmips)]=x
write.table(tab,file=paste0(opt$output,"/",opt$sample.name,"/",opt$sample.name,"_raw_coverage_per_smMIP.txt"),col.names = T,row.names = F,quote = F,sep = '\t')


################ ASSIGN THE SMMIP NAME AND THE UMI SEQUENCE TO THE READS NAME
if((length(unique(data$panel$length.left.umi))==1 & 0 %in% unique(data$panel$length.left.umi)) &
   (length(unique(data$panel$length.right.umi))==1 & 0 %in% unique(data$panel$length.right.umi))){
  data$samtable$umi=""
  cat("Adding smMIPs names to the reads names\n")
} else {cat("Adding smMIPs names and UMI sequences to the reads names\n")}

data<-adjust_readname(data)

################ WRITING UMI USAGE SUMMARY
if(!((length(unique(data$panel$length.left.umi))==1 & 0 %in% unique(data$panel$length.left.umi)) &
     (length(unique(data$panel$length.right.umi))==1 & 0 %in% unique(data$panel$length.right.umi)))){
  cat("Writing UMIs per smmip summary\n")
  tab=data.frame(V1=data$panel$id,V2=0,V3=0,V4=0,V5=NA)
  count=as.data.frame(data$umi_usage)
  count=as.data.frame(count %>% group_by(Var2) %>%
                        summarise("Total_unique_UMI_pairs_(molecules)"=length(which(Freq!=0)),Mean_family_size=mean(Freq[which(Freq!=0)]),Median_family_size=median(Freq[which(Freq!=0)])))
  names(count)[1]="smMIP"
  count$`Theoretical_limit_of_detection_(1/#molecules)`=1/count$`Total_unique_UMI_pairs_(molecules)`
  tab[match(count$smMIP,tab$V1),]=count
  names(tab)=names(count)
  write.table(tab,file=paste0(opt$output,"/",opt$sample.name,"/",opt$sample.name,"_UMI_usage_per_smMIP.txt"),col.names = T,row.names = F,quote = F,sep = '\t')
}

################ WRITING BAM/SAM FILES
cat("Writing the clean bam file\n")
#creating header
u=unique(data$samtable$rname)
header=as.data.frame(matrix(nrow = length(u)+2,ncol=11))
header[1:(length(u)+2),]=""
colnames(header)=colnames(data$samtable)
header[,1]=c(rep("@SQ",length(u)),"@RG","@PG")
header[,2]=c(paste0("SN:",u),paste0("ID:",opt$sample.name),"ID:bwa")
header[1:length(u),3]=rep("LN:1",length(u))

sorted_data <- rbind(header,as.data.frame(data$samtable[order(data$samtable$rname,data$samtable$pos),]))

library(stringr)
write.table(str_trim(apply(sorted_data, 1, paste, collapse='\t')),
            file=paste0(opt$output,"/",opt$sample.name,"/",opt$sample.name,"_clean.sam"),
            col.names = F,
            row.names = F,
            quote = F,
            sep = '\t') #Can be load to IGV

suppressWarnings(asBam(paste0(opt$output,"/",opt$sample.name,"/",opt$sample.name,"_clean.sam"),paste0(opt$output,"/",opt$sample.name,"/",opt$sample.name,"_clean"),overwrite=T))

if(opt$filtered.reads=="y"){ #
  cat("Writing the filtered reads sam file\n")
  data=write_reason_to_flitered_read(data)
  #creating header
  u=unique(data$filtered$rname)
  header=as.data.frame(matrix(nrow = length(u)+2,ncol=11))
  header[1:(length(u)+2),]=""
  colnames(header)=colnames(data$filtered)
  header[,1]=c(rep("@SQ",length(u)),"@RG","@PG")
  header[,2]=c(paste0("SN:",u),paste0("ID:",opt$sample.name),"ID:bwa")
  header[1:length(u),3]=rep("LN:1",length(u))
  l=as.data.frame(data$filtered[order(data$filtered$rname,data$filtered$pos),])
  l[] <- lapply(l, as.character)
  l[which(is.na(l),arr.ind = T)]=0
  write.table(rbind(header,l),file=paste0(opt$output,"/",opt$sample.name,"/",opt$sample.name,"_filtered.sam"),col.names = F,row.names = F,quote = F,sep = '\t')
} else if (opt$filtered.reads=="n"){
  #Delete the sam file
  #invisible(file.remove(paste0(opt$output,"/",opt$sample.name,"/",opt$sample.name,"_clean.sam")))
}

cat("\n")
cat("###############################\n")
cat("             DONE\n")
cat("###############################\n")
